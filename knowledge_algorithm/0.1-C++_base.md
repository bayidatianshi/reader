## C++参考教程 ##
https://www.w3cschool.cn/cpp/

## 基础 ##

### 简介 ###
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。

### 模板 ###

```cpp
#include <iostream>
using namespace std;

int main()
{
  int a = 1;
  cout << a;
  return 0;
}
```

### 注释 ###
- 单行`// 注释内容`
- 多行`/* 注释内容 */`

### 变量与类型 ###

- 基本数据类型（字节大小取本机）

```markup
bool     1个字节    false和true
char     1个字节    ASCII码为0到255的字符
int      4个字节    -2147483648 到 2147483647
float    4个字节    +/- 3.4e +/- 38 (~7 个数字)
double   8个字节    +/- 1.7e +/- 308(~15 个数字)
wchar_t  2个字节    1个宽字符
void     无类型     无类型
```

- 修饰符（可以添加多个）
	- signed 带符号
	- unsigned 无符号
	- short 短整型
	- long 长整型

- 存储类：定义变量/函数的范围和生命周期 `static int forever = 1;`
	- auto 默认缺省
	- register 用于快速访问的变量，通常由系统自行设定
	- static 保持局部变量的存在 / 使全局变量只对它所在的文件生效 / 使类数据成员
	- extern 引用其他文件的全局变量
	- mutable 

- 查看当前计算机的各种数据类型的大小：`sizeof(int)`
- 变量作用域
	- 全局变量:在所有函数外部定义的变量。全局变量在程序的整个生命周期内都是有效的
	- 局部变量:在函数或一个代码块内部声明的变量，只能在内部使用
- 变量应该在声明同时初始化
	- 当局部变量被定义时，您必须自行对其初始化，否则变量将包含某个随机值
	- 定义全局变量时，系统会自动初始化，数值型默认为0，字符型默认为'\0'，指针默认为NULL

- 常量：`const float  PI = 3.14;`
	- 整数常量：可加前后缀（例如 `0X123UL`表示十六进制无符号长整数123）
	- 字符常量：普通字符'x'，转义字符'\t'，通用字符'\u02C0'

### 运算符 ###

- 算数运算符：+ - * / ++ -- %（取模，整除后的余数）
- 关系运算符：== != > < >= <=
- 逻辑运算符：&& || ！
- 位运算符：  & | ^ ~ >> <<

```cpp
假设如果 A = 60，且 B = 13，先以二进制格式表示，然后逐位计算：
A       = 0011 1100 (60)
B       = 0000 1101 (13)
------------------------
A&B     = 0000 1100 (12)
A|B     = 0011 1101 (61)
A^B     = 0011 0001 (49)
~A      = 1100 0011 (-61)
A << 2  = 1111 0000 (240)
A >> 2  = 0000 1111 (15)
```

- 赋值运算符 `=` `算数运算符=` `位运算符=`
- 杂项运算符 
	- 强制类型转换 (type) expression
	- 条件运算符 Condition ? X : Y

**运算符优先级**

- 小括号
- 一元（++ -- !）
- 乘除
- 加减
- 移位（>> <<）
- 关系比较
- 位与
- 位或
- 逻辑与
- 逻辑或

### 循环 ###

- 循环语句
	- for
	- while
	- do while
	- 嵌套循环
- 循环控制
    - break 终止循环或switch
    - continue 跳过本次循环的剩余部分
    - goto 不常用
- 无限循环
```cpp
   for( ; ; )
   {
      printf("可以按 Ctrl + C 键终止无限循环");
   }
```

### 条件判断 ###

- Exp1 ? Exp2 : Exp3;
- if...else
- switch

```cpp
#include <iostream>
using namespace std;
 
int main ()
{
   // 局部变量声明
   char grade = 'D';
   switch(grade)
   {
   case 'A' :
      cout << "很棒！" << endl; 
      break;
   case 'B' :
   case 'C' :
      cout << "做得好" << endl;
      break;
   case 'D' :
      cout << "您通过了" << endl;
      break;
   case 'F' :
      cout << "最好再试一下" << endl;
      break;
   default :
      cout << "无效的成绩" << endl;
   }
   cout << "您的成绩是 " << grade << endl;
   return 0;
}
```

### 函数 ###

- 模板

```cpp
#include <iostream>
using namespace std;
// 函数定义
int max(int num1, int num2, int num3 = -999999)
{
  int result = -999999;
  result = num1 > num2 ? num1 : num2;
  result = result > num3 ? result : num3;
  return result;
}
int main()
{
  // 函数调用
  cout << max(1, 2) << endl;
  cout << max(1, 2, 3) << endl; // 默认参数被覆盖
  return 0;
}
```

- 传递参数的方式
    - 传值调用：将参数的实际值复制给形参，对原参数没有影响
    - 指针/引用调用：及那个参数的地址/引用复制给形参，修改形参会影响原参数

### 字符串 ###

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
  char s1[] = "Hello"; // 相当于 char s1[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
  strcat(s1, " world"); // 在末尾添加
  cout<< "字符串输出为" << s1 << endl;
  cout<< "字符串长度为" << strlen(s1) << endl;
  cout<< "字符串查找ll为" << strstr(s1, "ll") << endl;
  return 0;
}
```

### 数组 ###
- 使用方法

```cpp
#include <iostream>
using namespace std;
// 传递数组给函数
double getAverage(int arr[], int size)
{
  int i, sum = 0;
  double avg;
  for (i = 0; i < size; ++i)
  {
    sum += arr[i];
  }
  avg = double(sum) / size;
  return avg;
}
int main()
{
  // 定义一维数组
  int arr[3] = {1, 2, 3}; // 中括号内的数组长度可以不写，它会根据大括号的内容计算
  // 定义二维数组
  int a[3][4] = {
      {0, 1, 2, 3},  /*  初始化索引号为 0 的行 */
      {4, 5, 6, 7},  /*  初始化索引号为 1 的行 */
      {8, 9, 10, 11} /*  初始化索引号为 2 的行 */
  };
  // 调用形参为数组的函数，传递一个指向数组的指针作为参数
  int balance[5] = {1000, 2, 3, 17, 50};
  double avg;
  avg = getAverage(balance, 5);
  cout << "平均值是：" << avg << endl;
  return 0;
}
```

### 引用与指针 ###

```cpp
#include <iostream>
using namespace std;

int *fromPtoP(int *val, char *arr);
int main()
{
  int var = 20;
  int& otherName4var = var; // &作用：引用变量（起一个别名）/ 获取变量的地址
  otherName4var++; // var也会同步变化
  cout << "变量的实际值: " << var << endl;
  cout << "通过&获得变量的地址: " << &var << endl;

  int *ip = NULL; // 指针定义并初始化
  ip = &var;      // 用指针存储变量的地址
  cout << "指针存储的地址: " << ip << endl;
  cout << "访问指针所指向地址的值: " << *ip << endl;

  int **ipp = &ip; // 指向指针的指针
  cout << "指向指针的指针实现多级间接寻址: " << **ipp << endl;

  // 指向数组的指针
  double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
  double *p = balance;
  cout << "使用指针访问数组: ";
  for (int i = 0; i < 5; i++)
  {
    cout << *p << "     ";
    p++; // 能自动算出下个元素的地址值 &balance[i+1]
  }
  cout << endl;

  // 指针做参数，并返回指针
  int val;
  char arr[] = "hELLO";
  int *pr = fromPtoP(&val, arr);
  cout << "指针函数修改后的值: " << endl;
  cout << val << endl;
  cout << arr << endl;
  for (int i = 0; i < 3; i++)
  {
    cout << *(pr + i) << "    ";
  }
  return 0;
}
int *fromPtoP(int *val, char *arr)
{
  *val = 100;                 // 修改指针指向的变量
  arr[0] = 'H';               // 修改指针指向的数组
  static int r[] = {1, 2, 3}; // 返回局部变量的地址需要添加static
  return r;
}
```

## 进阶 ##

### 常用函数 ###
- swap(a, b)：交换两个变量的值，a与b需要是同一数据类型；无需引入额外头文件

### 输入输出 ###

- 标准输入输出

```cpp
int a;
cin>>a;
cout<<a;
```

- 文件输入输出

```cpp
#include <fstream>
#include <iostream>
using namespace std;
 
int main ()
{
    char data[100];

    // 以写模式打开文件,不存在的话会自动创建，默认存放路径为D:\work20210625\CPP\mingw64\bin
    ofstream outfile;
    outfile.open("afile.dat");

    cout << "Writing to the file" << endl;
    cout << "Enter your name: ";
    cin.getline(data, 100);

    // 向文件写入用户输入的数据
    outfile << data << endl;

    cout << "Enter your age: ";
    cin >> data;
    cin.ignore();

    // 再次向文件写入用户输入的数据
    outfile << data << endl;

    // 关闭打开的文件
    outfile.close();

    //以读模式打开文件
    ifstream infile;
    infile.open("afile.dat");

    cout << "Reading from the file" << endl;
    // 从文件中读取数据，并一行一行地打印出来
    while (infile >> data) {
        cout << data << endl;
    }

    // 关闭打开的文件
    infile.close();
    return 0;
}
```

### vector ###

- vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。
- 使用方法

```cpp
#include <iostream>
#include <vector>    // 使用vector前先引入
#include <algorithm> // 使用算法sort、reverse、最值前先引入
#include <iomanip>   // 使用控制符setw前先引入
#include <numeric> // accumulate
#include <bits/stdc++.h> // 万用头
using namespace std;
bool Comp(const int &a, const int &b)
{
  return a > b; // 从大到小排序的比较函数
}
int main()
{
  vector<int> vec;  // 创建一个vector
  vec.push_back(1); // 在尾部添加元素
  for (int i = 2; i <= 6; i++)
  {
    vec.push_back(i);
  }
  cout << "vec[0]为：" << vec[0] << endl;                  // 使用下标访问
  cout << "vec.max_size()为：" << vec.max_size() << endl;  // vector最大可分配大小
  cout << "vec.capacity ()为：" << vec.capacity() << endl; // 当前vector分配的大小
  cout << "vec.size()为：" << vec.size() << endl;          // 当前使用数据的大小
  // insert函数（双参数）：在指定下标的元素前添加元素，例如在下标为index0的元素前面插入num0
  int index0 = 0, num0 = 0;
  vec.insert(vec.begin() + index0, num0);
  // erase函数（双参数）：删除指定区间内的元素，例如删除下标在[deleB, deleE)中的元素
  int deleB = 2, deleE = 4;
  vec.erase(vec.begin() + deleB, vec.begin() + deleE);
  // erase函数（单参数）：删除指定元素，例如倒数第二个
  vec.erase(vec.end() - 2);
  // pop_back函数：删除最后一个元素
  vec.pop_back();
  // 使用迭代器访问，begin()是头元素指针，end()是尾元素 + 1 的指针
  cout << endl << "vec迭代器：" << endl;
  for (vector<int>::iterator it = vec.begin(); it != vec.end(); it++)
  {
    cout << *it << "    ";
  }
  // 使用反向迭代器访问，rbegin()是尾元素指针，rend()是头元素 - 1 的指针
  cout << endl << "vec迭代器：" << endl;
  for(vector<int>::reverse_iterator it = vec.rbegin(); it!=vec.rend();it++){
      cout << *it << "    ";
  }
  // sort算法函数：元素排序（不写Comp参数的话默认从小到大）
  sort(vec.begin(), vec.end(), Comp);
  cout << endl << "sort从大到小：" << endl;
  for (vector<int>::iterator it = vec.begin(); it != vec.end(); it++)
  {
    cout << *it << "    ";
  }
  // reverse算法函数：元素逆序
  reverse(vec.begin(), vec.end());
  cout << endl << "reverse逆序：" << endl;
  for (vector<int>::iterator it = vec.begin(); it != vec.end(); it++)
  {
    cout << *it << "    ";
  }
  // accumulate函数：求和
  int sum = accumulate(vec.begin(), vec.end(), 0); // 第三参数为求和初始值
  cout << endl << "accumulate求和：" << endl;
  cout << sum << endl;
  // 最值
  vector<int>::iterator itMax = max_element(vec.begin(), vec.end());
  vector<int>::iterator itMin = min_element(vec.begin(), vec.end());
  int max = *max_element(vec.begin(), vec.end());
  int min = *min_element(vec.begin(), vec.end());
  cout << "最大值为：" << max << " " << "所在位置：" << distance(vec.begin(), itMax) << endl;
  cout << "最小值为：" << min << " " << "所在位置：" << distance(vec.begin(), itMin) << endl;
    return 0;
  // clear函数：清空元素
  vec.clear();
  // 二维向量：
  cout << endl << "二维向量：" << endl;
  int N = 5, M = 6;
  vector<vector<int>> obj(N, vector<int>(M)); //定义二维动态向量5行6列
  for (int i = 0; i < obj.size(); i++)        //输出二维动态向量
  {
    for (int j = 0; j < obj[i].size(); j++)
    {
      obj[i][j] = i * M + j; // 初始化
      cout << setw(8) << obj[i][j]; // 为了观赏性，输出前进行宽度设置
    }
    cout << "\n";
  }
  return 0;
}
```

- 构造函数

```cpp
vector<int> a = {-1, 0, 3, 5, 9, 12}; // 定义向量并初始化
vector<int> a(10,1); // 定义了10个整型元素的向量,且给出每个元素的初值为1
vector<int> a(b); // 将b向量复制到a向量
vector<int> a(b.begin(),b.begin()+3); // 定义了a值为b中第0个到第2个（共3个）元素
int b[7]={1,2,3,4,5,6,7}; vector<int> a(b,b+7); // 从数组中获得初值
```
- 增加函数

```cpp
​push_back(x); // 向量尾部增加一个元素X
​insert(vec.begin() + index, x); // 在下标为index的元素前增加一个元素x
​insert(vec.begin() + index, n, x); // 在下标为index的元素前增加n个相同的元素x
​insert(vec.begin() + index, vec2.begin(), vec2.end()); // 在下标为index的元素前插入另一个相同类型向量的[first,last)间的数据
```

### 单链表 ###
- 默认构造函数的单链表

```cpp
#include <iostream>
using namespace std;
struct ListNode {
    double value;
    ListNode *next;
};
int main()
{
    ListNode *head = nullptr; // 定义单链表的head指针并初始化
    // 创建第一个节点
    head = new ListNode; // 给第一个节点分配内存，head指针保存该内存的地址
    head->value = 12.5; // head指针的指向（即第一个节点）中的value数据赋值为12.5
    head->next = nullptr; // head指针的指向（即第一个节点）中的next指针赋值为空
    // 创建第二个节点
    ListNode *secondPtr = new ListNode; // 给第二个节点分配内存，secondPtr指针保存该内存的地址
    secondPtr->value = 13.5; // secondPtr指针的指向（即第二个节点）中的value数据赋值为13.5
    secondPtr->next = nullptr; // secondPtr指针的指向（即第二个节点）中的next指针赋值为空
    head->next = secondPtr; // head指针的指向（即第一个节点）中的next指针赋值为secondPtr指针，第一个和第二个节点因此连起来了
    // 打印相关信息
    cout << "head指针存储第一个节点的地址：" << head << endl;
    cout << "head->next指针存储第二个节点的地址：" << head->next << endl;
    cout << "第一个节点的数据通过head->value获取：" << head->value << endl;
    cout << "第二个节点的数据通过head->next->value获取：" << head->next->value << endl;
    return 0;
}
```

- 自定义构造函数的单链表

```cpp
#include <algorithm>
#include <fstream>
#include <iostream>
#include <vector>
using namespace std;
struct ListNode {
    double value;
    ListNode* next;
    // 自定义构造函数
    ListNode(double value1, ListNode* next1 = nullptr) {
        value = value1;
        next = next1;
    }
};

int main() {
    ListNode* head = new ListNode(13.5);
    head = new ListNode(
        12.5,
        head);  // 该语句将从右到左，首先在构造函数中使用head的旧值，然后从new运算符返回的地址将被分配给head，成为它的新值
    cout << "head指针存储第一个节点的地址：" << head << endl;
    cout << "head->next指针存储第二个节点的地址：" << head->next << endl;
    cout << "第一个节点的数据通过head->value获取：" << head->value << endl;
    cout << "第二个节点的数据通过head->next->value获取：" << head->next->value
         << endl;
    // 使用 ListNode 的构造函数版本，可以很轻松地创建一个链表
    // 根据数组创建链表，需要反向遍历
    vector<int> nums = {2, 3, 1, 2, 4, 3};
    ListNode* list1 = nullptr;
    for (vector<int>::reverse_iterator it = nums.rbegin(); it != nums.rend();
         it++) {
        list1 = new ListNode(*it, list1);
    }
    // 遍历链表
    ListNode* ptr = list1;
    while (ptr != nullptr) {
        cout << ptr->value << " ";  // Process node
        ptr = ptr->next;            // Move to next node
    }
    // 根据文件内容创建链表，默认的文件存放路径为D:\work20210625\CPP\mingw64\bin
    double number;                   // Used to read the file
    ListNode* numberList = nullptr;  // List of numbers
    // Open the file
    ifstream numberFile("numberFile.dat", ios::in);
    if (!numberFile) {
        cout << "Error in opening the file of numbers.";
        exit(1);
    }
    // Read the file into a linked list
    cout << "The contents of the file are: " << endl;
    while (numberFile >> number) {
        cout << number << " ";
        // Create a node to hold this number
        numberList = new ListNode(number, numberList);
    }
    // Traverse the list while printing
    cout << endl << "The contents of the list are: " << endl;
    ListNode* ptr2 = numberList;
    while (ptr2 != nullptr) {
        cout << ptr2->value << " ";  // Process node
        ptr2 = ptr2->next;           // Move to next node
    }
    return 0;
}
```

- 附带增删查打印功能的单链表

```cpp
#include <bits/stdc++.h>  // 万用头
using namespace std;

class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            cout<<"出错! get(int index)中index为"<< index <<endl;
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index>0){ // 如果--index 就会陷入死循环,因为while(-1)也是按true处理
            cur = cur->next;
            index--;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead; // 因为要预判后一位，所以直接指向虚拟头指针，来统一操作
        while(cur->next != nullptr){ // 预判后一位是否为空指针
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，如果index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度或index为负数，则返回空
    void addAtIndex(int index, int val) {
        if (index > _size ||  index < 0) {
            cout<<"出错! addAtIndex(int index, int val)中index为"<< index <<endl;
            return;
        }
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index>0) {
            cur = cur->next;
            index--;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            cout<<"出错! deleteAtIndex(int index)中index为"<< index <<endl;
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index>0) {
            cur = cur ->next;
            index--;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode *cur = _dummyHead->next;
        while(cur != nullptr) {
            cout<<cur->val<<' ';
            cur = cur->next;
        }
        cout<<endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;

};
int main() {

    MyLinkedList linkedList;
    linkedList.addAtHead(1);
    linkedList.addAtTail(3);
    linkedList.addAtIndex(1,2); //链表变为1-> 2-> 3
    linkedList.printLinkedList();
    cout<<linkedList.get(1)<<endl; //返回2
    linkedList.deleteAtIndex(1); //现在链表是1-> 3
    cout<<linkedList.get(1)<<endl; //返回3

    return 0;
}

```
### map ###

- key-value键值对容器，每个关键字只能在 map 中出现一次
- 使用方法

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;
typedef map<int, string> NumMapStu; // 换个名字方便书写
int main()
{
  NumMapStu mapStudent;
  // 插入或修改元素
  mapStudent[1] = "student_one";
  mapStudent[2] = "student";
  mapStudent[2] = "student_two";
  mapStudent[3] = "student_three";
  cout << "map的size():" << mapStudent.size() << endl;
  // find()查找:找到就返回所在位置的迭代器，否则返回end迭代器
  NumMapStu::iterator findKey = mapStudent.find(1);
  if (findKey != mapStudent.end())
  {
    cout << "Found! The value is : " << findKey->second << endl;
  }
  else
  {
    cout << "Not found." << endl;
  }
  // 遍历
  cout << "前向遍历" << endl;
  for (NumMapStu::iterator iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
  {
    cout << iter->first << ' ' << iter->second << endl;
  }
  cout << "反向遍历" << endl;
  for (NumMapStu::reverse_iterator iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++)
  {
    cout << iter->first << ' ' << iter->second << endl;
  }
  // erase()删除
  mapStudent.erase(3); // 根据key删除
  mapStudent.erase(mapStudent.begin()); // 根据迭代器删除
  mapStudent.clear(); // 全部删除
  
  cout << "前向遍历" << endl;
  for (NumMapStu::iterator iter = mapStudent.begin(); iter != mapStudent.end(); iter++)
  {
    cout << iter->first << ' ' << iter->second << endl;
  }
  return 0;
}
```

### ctime ###

```cpp
#include <iostream>
#include <ctime>
using namespace std;
int main( )
{
   // 基于当前系统的当前日期/时间
   time_t now = time(0);
   cout << "1970年1月1日到目前经过的秒数:" << now << endl;
   tm *ltm = localtime(&now);
   // 输出 tm 结构的各个组成部分
   cout << "年: "<< 1900 + ltm->tm_year << endl;
   cout << "月: "<< 1 + ltm->tm_mon<< endl;
   cout << "日: "<<  ltm->tm_mday << endl;
   cout << "时间: "<< ltm->tm_hour << ":" << ltm->tm_min << ":" << ltm->tm_sec << endl;
}
```

### cmath ###
- 使用前先引入 `#include <cmath>`
- 三角函数： `sin/cos/tan()`返回弧度角（double型）的正弦/余弦/正切值
- 对数：`double log(double)`返回参数的自然对数
- 次方：`double pow(double x, double y)`返回 x 的 y 次方
- 平方根：`double sqrt(double)`
- 绝对值：`abs(-1.2)`
- 向下取整：`floor(-1.2)`
- 随机数

```cpp
#include <iostream>
#include <ctime>
#include <cmath>
using namespace std;
int main()
{
  srand((unsigned)time(NULL)); // 设置种子，否则每轮生成的随机数相同
  for (int i = 0; i < 10; i++)
  {
    int a = rand();
    cout << a << "    ";
  }
  return 0;
}
```
## 典例 ##

### N进制转M进制 ###