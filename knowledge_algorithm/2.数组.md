## 数组
- 数组是存放在连续内存空间上的相同类型数据的集合
- 因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210414122642370.png)

- 二维数组在内存的空间地址是否连续与编程语言的内存管理有关，C++连续，JAVA不连续。

### [数组二分查找](https://leetcode-cn.com/problems/binary-search/)
- 题目：
![在这里插入图片描述](https://img-blog.csdnimg.cn/94084d780a6247b984bd94de8a92d121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1YW5nX2FuZw==,size_16,color_FFFFFF,t_70)

- 方法：题目已经明确说明用二分查找
- 前提：**二分查找的前提为数组有序且不重复**，题目已经满足
- 思考过程的形象表达（脑海浮现/图解/动画）：略
- 思路（文字伪代码）：比较target与数组中间值，相等则返回中间值下标；由于升序，小于则把左半区间作为新数组；大于则将数组右半区间看作新数组；**比较target与新数组中间值，循环反复，直到找到与target相等的值或者无法形成新数组**。形成的新数组可以用下标区间[left, right]表示，例如刚开始的数组区间为[0, 末元素下标]，左半区间为[0, 中元素下标-1]，右半区间为[中元素下标+1, 末元素下标]。在循环比较的过程中，若找到target则返回中元素的下标，否则不断修改right或left的值来形成新的左半区间[left, 中元素下标-1]或右半区间[中元素下标+1, right]，当left>right，区间不成立，无法形成新数组，说明没找到与target相等的值，可以返回-1了。
- 根据思路写出代码：

```cpp
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int middle = (left + right) / 2;
        if (target > nums[middle]) {
            left = middle + 1;
        } else if (target < nums[middle]) {
            right = middle - 1;
        } else {
            return middle;
        }
    }
    return -1;
}
```
- 特殊情况分析
	- left=right 可行
	- 根据题目去数组长度最小值1 可行
- 优化：`int middle = left + ((right - left) / 2);`可以防止left + right溢出
- 时间复杂度
- 空间复杂度


